import { LicenseCategory, categorizeLicense } from '@callstack/licenses';
import { RefreshTwoTone } from '@mui/icons-material';
import { Alert, Box, Button, CircularProgress, LinearProgress, Skeleton, Stack, Typography } from '@mui/material';
import React, { useCallback, useEffect, useRef, useState } from 'react';

import { SummarizerState, useSummarizerStore } from '@/store/summarizerStore';
import { useVisualizerStore } from '@/store/visualizerStore';
import { buildDependencyGraph } from '@/utils/buildDependencyGraph';

import ExternalLink from '../ExternalLink';
import MarkdownBlock from '../MarkdownBlock';

import { useTabsStyles } from './styles';

export default function Summary() {
  const { classes } = useTabsStyles();
  const { selectedRoot, report } = useVisualizerStore();
  const { ensureInitialized, tldrSummarizer, keyPointsSummarizer, summarizerDownloadProgress, summarizerState } =
    useSummarizerStore();

  const [summary, setSummary] = useState<string | null>(null);
  const [markdownProblematicDependencyChains, setMarkdownProblematicDependencyChains] = useState('');
  const [regenerateSummaryToken, setRegenerateSummaryToken] = useState(0);

  const lastSummarizationTokenRef = useRef(0);

  // ensure summarizer initialized effect
  useEffect(() => {
    ensureInitialized();
  }, [ensureInitialized]);

  // prepare a summary of the current
  useEffect(() => {
    if (!tldrSummarizer || !keyPointsSummarizer || !report) return;

    const taskToken = ++lastSummarizationTokenRef.current;

    const markdownProblematicDependencyChains = Object.entries(report)
      .filter(([, license]) => categorizeLicense(license.type) !== LicenseCategory.PERMISSIVE)
      .map(([packageKey, license]) => {
        const { graph } = buildDependencyGraph(report, report[packageKey]);

        const predecessors: Set<string> = new Set();

        let predecessorsBuff: string[] | undefined = [packageKey];
        while (predecessorsBuff?.length) {
          let newPredecessorsBuff: string[] | undefined = [];

          for (const predecessor of predecessorsBuff) {
            if (predecessors.has(predecessor)) continue;

            predecessors.add(predecessor);

            const nextPredecessors = graph.predecessors(predecessor);

            if (nextPredecessors) {
              newPredecessorsBuff.push(...nextPredecessors);
            }
          }

          if (!newPredecessorsBuff.length) {
            newPredecessorsBuff = undefined;
          }

          predecessorsBuff = newPredecessorsBuff;
        }

        return `- \`${packageKey}\`: ${license.type} license${
          license.parentPackages.length
            ? `, is introduced to the project by the following libraries: ${Array.from(predecessors)
                .toReversed()
                .map((key) => `\`${key}\``)
                .join(' - ')}`
            : ''
        }`;
      })
      .join('\n');

    const graphDescription =
      'Core analysis: project graph includes the following packages that were not classified as fully permissive:\n' +
      markdownProblematicDependencyChains.replaceAll('`', '');

    setMarkdownProblematicDependencyChains(markdownProblematicDependencyChains);

    console.log('Running AI summarizations (TLDR + Key Points) of the following text:\n', graphDescription);

    setSummary(null);

    // eslint-disable-next-line promise/catch-or-return, promise/prefer-await-to-then -- useEffect does not support async functions
    Promise.all([tldrSummarizer.summarize(graphDescription), keyPointsSummarizer.summarize(graphDescription)]).then(
      ([tldr, keyPoints]) => {
        // check if this is the most up-to-date task
        // eslint-disable-next-line promise/always-return
        if (lastSummarizationTokenRef.current === taskToken) {
          console.log('Generated summary:\n', tldr, keyPoints);

          setSummary('##### TL;DR of the project\n' + tldr + '\n\n##### Key points\n' + keyPoints);
        }
      },
    );
  }, [report, selectedRoot, regenerateSummaryToken, tldrSummarizer, keyPointsSummarizer]);

  const regenerateSummary = useCallback(() => {
    setRegenerateSummaryToken((previous) => previous + 1);
  }, []);

  return (
    <Box className={classes.container}>
      <Box className={classes.gridContainer}>
        <Box className={classes.groupContainer}>
          <Stack justifyContent="space-between" alignItems="center" direction="row" mb={2}>
            <Typography variant="subtitle1" gutterBottom>
              AI-generated summary
            </Typography>

            <Button startIcon={<RefreshTwoTone />} onClick={regenerateSummary}>
              Re-generate
            </Button>
          </Stack>

          <Alert severity="info" sx={{ mb: 2 }}>
            The information below is generated by your browser&apos;s built-in language model using the{' '}
            <ExternalLink href="https://webmachinelearning.github.io/writing-assistance-apis/#summarizer" inline>
              Summarization API
            </ExternalLink>
            , based on information from the report. Please be aware that the information may not be accurate or even may
            be false, as it usual with language models.
          </Alert>

          {summarizerState === SummarizerState.CHECKING_AVAILABILITY ? (
            <CircularProgress />
          ) : summarizerState === SummarizerState.UNAVAILABLE ? (
            <Typography>
              Sorry, the required Summarization API is not available on your browser. Please consult{' '}
              <ExternalLink href="https://caniuse.com/mdn-api_summarizer" inline>
                Can I use...
              </ExternalLink>{' '}
              to check which browsers currently supports it.
            </Typography>
          ) : summarizerState === SummarizerState.DOWNLOADING ? (
            <Stack justifyContent="center" alignContent="center" gap={1} direction="column">
              <LinearProgress value={summarizerDownloadProgress} />

              <Typography textAlign="center">
                Downloading Summarization API model - {summarizerDownloadProgress}%
              </Typography>
            </Stack>
          ) : summary ? (
            <MarkdownBlock>
              {'#### AI-generated summary\n' +
                summary +
                '\n\n#### Additional details for licenses not classified as fully permissive *(these are non-AI-generated)*:\n' +
                markdownProblematicDependencyChains}
            </MarkdownBlock>
          ) : (
            <>
              <Skeleton />
              <Skeleton />
              <Skeleton />
              <Skeleton />
              <Skeleton />
              <Skeleton width="80%" />

              <br />

              <Skeleton />
              <Skeleton />

              <br />

              <Skeleton />
              <Skeleton />

              <br />

              <Skeleton />
              <Skeleton width="40%" />
            </>
          )}
        </Box>
      </Box>
    </Box>
  );
}
